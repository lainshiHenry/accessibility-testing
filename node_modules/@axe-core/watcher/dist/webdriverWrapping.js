"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapElement = exports.wrapTargetLocator = exports.wrapNavigation = exports.wrapDriver = void 0;
const proxyHandlers_1 = require("./utils/proxyHandlers");
const wrapDriver = (driver, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(driver)) {
        return driver;
    }
    const proxy = new Proxy(driver, {
        get(target, prop) {
            switch (prop) {
                case 'findElement':
                    return async (locator) => {
                        const el = await target.findElement(locator);
                        return (0, exports.wrapElement)(el, controller);
                    };
                case 'quit':
                    return async () => {
                        await controller.flush();
                        return target.quit();
                    };
                case 'close':
                    return async () => {
                        await controller.flush();
                        return target.close();
                    };
                case 'findElements':
                    return async (locator) => {
                        const els = await target.findElements(locator);
                        return els.map(el => (0, exports.wrapElement)(el, controller));
                    };
                case 'switchTo':
                    return () => (0, exports.wrapTargetLocator)(target.switchTo(), controller);
                case 'navigate':
                    return () => (0, exports.wrapNavigation)(target.navigate(), controller);
                case 'get':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapDriver = wrapDriver;
const wrapNavigation = (navigation, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(navigation)) {
        return navigation;
    }
    const proxy = new Proxy(navigation, {
        get(target, prop) {
            switch (prop) {
                case 'back':
                case 'forward':
                case 'refresh':
                case 'to':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapNavigation = wrapNavigation;
const wrapTargetLocator = (locator, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(locator)) {
        return locator;
    }
    const proxy = new Proxy(locator, {
        get(target, prop) {
            switch (prop) {
                case 'activeElement':
                    return async () => {
                        const el = await target.activeElement();
                        return (0, exports.wrapElement)(el, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapTargetLocator = wrapTargetLocator;
const wrapElement = (element, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(element)) {
        return element;
    }
    const proxy = new Proxy(element, {
        get(target, prop) {
            switch (prop) {
                case 'getDriver':
                    return () => (0, exports.wrapDriver)(target.getDriver(), controller);
                case 'findElement':
                    return async (locator) => {
                        const el = await target.findElement(locator);
                        return (0, exports.wrapElement)(el, controller);
                    };
                case 'findElements':
                    return async (locator) => {
                        const els = await target.findElements(locator);
                        return els.map(el => (0, exports.wrapElement)(el, controller));
                    };
                case 'clear':
                case 'click':
                case 'sendKeys':
                case 'submit':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapElement = wrapElement;
//# sourceMappingURL=webdriverWrapping.js.map