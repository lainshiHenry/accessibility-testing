"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WRAPPED_COMMANDS = void 0;
const cypressConfigRunFlag = '__AXE_WATCHER_CYPRESS_CONFIG_RUN';
let isStopped = false;
exports.WRAPPED_COMMANDS = [
    'blur',
    'check',
    'clear',
    'click',
    'dblclick',
    'focus',
    'go',
    'reload',
    'scrollIntoView',
    'scrollTo',
    'select',
    'submit',
    'trigger',
    'type',
    'uncheck',
    'visit',
    'wait'
];
const logDebugAxeWatcher = ({ message }) => {
    if (Cypress.env('__AXE_WATCHER_DEBUG')) {
        cy.task('__debugAxeWatcher', message, { log: false });
    }
};
const shouldAnalyzeLocation = (location) => ['http:', 'https:', 'file:'].includes(location.protocol);
if (!Cypress.env(cypressConfigRunFlag)) {
    throw new Error(`Cypress is not configured for axe watcher. Please ensure that axe watcher's cypressConfig() is invoked within Cypress' defineConfig() in your ${Cypress.config('configFile')}. All tests will fail with this error.`);
}
exports.WRAPPED_COMMANDS.forEach(method => Cypress.Commands.overwrite(method, (originalFn, ...args) => {
    var _a, _b, _c, _d, _e;
    const currentCommand = cy.state('current');
    const currentCommandName = currentCommand === null || currentCommand === void 0 ? void 0 : currentCommand.get('name');
    const currentCommandType = currentCommand === null || currentCommand === void 0 ? void 0 : currentCommand.get('type');
    const tryRequerySubject = !!Cypress.env('__AXE_WATCHER_CYPRESS_REQUERY_SUBJECT_AFTER_ANALYZE') &&
        'getSubjectFromChain' in cy;
    if (currentCommandName && currentCommandName !== method) {
        return originalFn(...args);
    }
    const originalSubject = (_b = (_a = cy).subject) === null || _b === void 0 ? void 0 : _b.call(_a);
    const originalSubjectChain = (_d = (_c = cy).subjectChain) === null || _d === void 0 ? void 0 : _d.call(_c);
    let commandChain = cy.window().axeWatcherAnalyze({
        __Method: method,
        __UserRequestedAnalyze: false
    });
    if (tryRequerySubject) {
        const timeout = (_e = args.find(arg => arg === null || arg === void 0 ? void 0 : arg.timeout)) === null || _e === void 0 ? void 0 : _e.timeout;
        commandChain = commandChain.__axeRestoreSubject(originalSubjectChain, timeout);
        commandChain.then({ timeout: 999999 }, refreshedSubject => originalFn(...updateSubject(args, currentCommandType, refreshedSubject)));
    }
    else {
        commandChain
            .then(() => originalSubject)
            .then(() => originalFn(...args));
    }
}));
function updateSubject(args, commandType, refreshedSubject) {
    if (commandType === 'parent') {
        return args;
    }
    else {
        return [refreshedSubject, ...args.slice(1)];
    }
}
Cypress.Commands.addQuery('__axeRestoreSubject', function (subjectChain, timeout) {
    this.set('timeout', timeout);
    this.set('onFail', (err) => {
        const runner = cy.state('runnable');
        err.codeFrame = runner.invocationDetails;
    });
    return () => cy.getSubjectFromChain(subjectChain);
});
function axeWatcherFlushCommand() {
    logDebugAxeWatcher({ message: 'Flush: Invoked (may analyze implicitly)' });
    cy.window().then(win => {
        if (!shouldAnalyzeLocation(win.location)) {
            return Promise.resolve();
        }
        return new Promise(resolve => {
            const results = [];
            const onAxeResult = (event) => {
                results.push(...event.detail);
            };
            const onFlushEnd = () => {
                win.removeEventListener('axe:flush-end', onFlushEnd);
                win.removeEventListener('axe:result', onAxeResult);
                resolve(results);
            };
            win.addEventListener('axe:flush-end', onFlushEnd);
            win.addEventListener('axe:result', onAxeResult);
            const event = new CustomEvent('axe:flush-start');
            win.dispatchEvent(event);
        }).then(results => {
            cy.task('__uploadAxeWatcherResults', { results }, { log: false });
            logDebugAxeWatcher({ message: 'Flush: complete' });
        });
    });
}
const doesCypressCommandExist = (commandName) => {
    return !!Cypress.cy[commandName];
};
function axeWatcherAnalyzeCommand({ __Method, __UserRequestedAnalyze = true } = {}) {
    logDebugAxeWatcher({
        message: `Analyze: Invoked${__Method ? ` - ${__Method}` : ''}`
    });
    const userRequestedAnalyze = __UserRequestedAnalyze;
    cy.window().then(win => {
        if (!shouldAnalyzeLocation(win.location)) {
            return Promise.resolve({ message: `Skipped - Invalid protocol` });
        }
        if (isStopped && !userRequestedAnalyze) {
            return Promise.resolve({ message: `Skipped (Manual mode)` });
        }
        return new Promise(resolve => {
            const fn = (event) => {
                win.removeEventListener('axe:manual-mode-analyze-done', fn);
                resolve(event.detail);
            };
            win.addEventListener('axe:manual-mode-analyze-done', fn);
            const event = new CustomEvent('axe:manual-mode-analyze', {
                detail: { userRequestedAnalyze }
            });
            win.dispatchEvent(event);
        }).then(result => {
            logDebugAxeWatcher({ message: `Analyze: ${result === null || result === void 0 ? void 0 : result.message}` });
        });
    });
}
function axeWatcherStartCommand() {
    cy.window().then(win => {
        if (!shouldAnalyzeLocation(win.location)) {
            return Promise.resolve();
        }
        return new Promise(resolve => {
            const fn = () => {
                win.removeEventListener('axe:start-auto-mode-done', fn);
                resolve();
            };
            win.addEventListener('axe:start-auto-mode-done', fn);
            const event = new CustomEvent('axe:start-auto-mode');
            win.dispatchEvent(event);
        }).then(() => {
            isStopped = false;
        });
    });
}
function axeWatcherStopCommand() {
    cy.window().then(win => {
        if (!shouldAnalyzeLocation(win.location)) {
            return Promise.resolve();
        }
        return new Promise(resolve => {
            const fn = () => {
                win.removeEventListener('axe:stop-auto-mode-done', fn);
                resolve();
            };
            win.addEventListener('axe:stop-auto-mode-done', fn);
            const event = new CustomEvent('axe:stop-auto-mode');
            win.dispatchEvent(event);
        }).then(() => {
            isStopped = true;
        });
    });
}
if (!doesCypressCommandExist('axeAnalyze')) {
    Cypress.Commands.add('axeAnalyze', axeWatcherAnalyzeCommand);
}
Cypress.Commands.add('axeFlush', axeWatcherFlushCommand);
Cypress.Commands.add('axeStop', axeWatcherStopCommand);
Cypress.Commands.add('axeStart', axeWatcherStartCommand);
Cypress.Commands.add('axeWatcherAnalyze', axeWatcherAnalyzeCommand);
Cypress.Commands.add('axeWatcherStart', axeWatcherStartCommand);
Cypress.Commands.add('axeWatcherStop', axeWatcherStopCommand);
Cypress.Commands.add('axeWatcherFlush', axeWatcherFlushCommand);
//# sourceMappingURL=cypressCommands.js.map