"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapWdio = exports.WRAPPED_ELEMENT_METHODS = exports.WRAPPED_BROWSER_METHODS = exports.WdioController = void 0;
exports.wdioConfig = wdioConfig;
exports.wdioTestRunner = wdioTestRunner;
const fs_1 = __importDefault(require("fs"));
const Controller_1 = __importDefault(require("./Controller"));
const writeVariables_1 = __importDefault(require("./utils/writeVariables"));
const constants_1 = require("./utils/constants");
const headlessNotSupportedError_1 = require("./utils/headlessNotSupportedError");
const mergeChromeArgs_1 = __importDefault(require("./utils/mergeChromeArgs"));
const noop = () => {
};
function wdioConfig({ axe, ...options }) {
    var _a;
    (0, writeVariables_1.default)(axe);
    const chromeOpts = ((_a = options.capabilities) === null || _a === void 0 ? void 0 : _a['goog:chromeOptions']) || {};
    const args = chromeOpts.args || [];
    if (['headless', '--headless'].some(flag => args.includes(flag))) {
        throw new headlessNotSupportedError_1.HeadlessNotSupportedError(`In WebdriverIO, use "headless=new" instead of "headless" in the "args" property of your "${CHROME_OPTIONS}" browser capability configuration.`);
    }
    return {
        ...options,
        capabilities: {
            ...options === null || options === void 0 ? void 0 : options.capabilities,
            browserName: 'chrome',
            'goog:chromeOptions': {
                args: (0, mergeChromeArgs_1.default)(args, { disableOtherExtensions: true })
            }
        }
    };
}
const CHROME_OPTIONS = 'goog:chromeOptions';
function wdioTestRunner(...params) {
    let axe;
    let config;
    if (params.length === 1) {
        ;
        ({ axe, ...config } = params[0]);
    }
    else {
        ;
        [axe, config] = params;
    }
    (0, writeVariables_1.default)(axe);
    const capabilities = config.capabilities || [
        { [CHROME_OPTIONS]: { args: [] } }
    ];
    const firstCapability = capabilities[0];
    firstCapability[CHROME_OPTIONS] = firstCapability[CHROME_OPTIONS] || {};
    const chromeOpts = firstCapability[CHROME_OPTIONS];
    chromeOpts.args = chromeOpts.args || [];
    const args = chromeOpts.args;
    if (['headless', '--headless'].some(flag => args.includes(flag))) {
        throw new headlessNotSupportedError_1.HeadlessNotSupportedError(`In WebdriverIO, use "headless=new" instead of "headless" in the "args" property of your "${CHROME_OPTIONS}" browser capability configuration.`);
    }
    chromeOpts.args = (0, mergeChromeArgs_1.default)(args, { disableOtherExtensions: false });
    const { onPrepare = noop, onComplete = noop } = config;
    return {
        ...config,
        capabilities,
        onPrepare(...prepareParams) {
            const sessionId = axe.sessionId;
            const buildID = axe.buildID;
            if (!buildID) {
                fs_1.default.writeFileSync(constants_1.PATH_TO_SESSION_FILE, JSON.stringify({ id: sessionId }));
            }
            return onPrepare(...prepareParams);
        },
        onComplete(...completeParams) {
            try {
                fs_1.default.unlinkSync(constants_1.PATH_TO_SESSION_FILE);
            }
            catch (_a) {
            }
            return onComplete(...completeParams);
        }
    };
}
class WdioController extends Controller_1.default {
    constructor(driver) {
        super({ debugLoggerName: 'WdioController' });
        this.driver = driver;
    }
    async executeScript(fn, ...args) {
        const script = `
      const callback = arguments[arguments.length - 1];
      Promise.resolve(...arguments)
        .then(${fn})
        .then(callback);
    `;
        const result = await this.driver.executeAsync(script, ...args);
        return result;
    }
}
exports.WdioController = WdioController;
exports.WRAPPED_BROWSER_METHODS = [
    'reloadSession',
    'setWindowSize',
    'switchWindow',
    'touchAction',
    'newWindow',
    'pause',
    'url',
    'waitUntil'
];
exports.WRAPPED_ELEMENT_METHODS = [
    'addValue',
    'clearValue',
    'click',
    'doubleClick',
    'dragAndDrop',
    'moveTo',
    'scrollIntoView',
    'setValue',
    'touchAction',
    'waitForClickable',
    'waitForDisplayed',
    'waitForEnabled',
    'waitForExist',
    'waitUntil'
];
const wrapWdio = (browser, controller) => {
    const wrapper = async (fn, ...args) => {
        const res = await fn(...args);
        await controller.analyze({ __UserRequestedAnalyze: false });
        return res;
    };
    for (const method of exports.WRAPPED_BROWSER_METHODS) {
        browser.overwriteCommand(method, wrapper);
    }
    for (const method of exports.WRAPPED_ELEMENT_METHODS) {
        browser.overwriteCommand(method, wrapper, true);
    }
    return browser;
};
exports.wrapWdio = wrapWdio;
//# sourceMappingURL=wdio.js.map