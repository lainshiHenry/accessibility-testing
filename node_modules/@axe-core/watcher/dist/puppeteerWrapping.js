"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapJSHandle = exports.wrapLocator = exports.wrapFrame = exports.wrapDialog = exports.wrapTouchscreen = exports.wrapMouse = exports.wrapKeyboard = exports.wrapElementHandle = exports.wrapTarget = exports.wrapPage = exports.wrapBrowser = exports.wrapBrowserContext = void 0;
const proxyHandlers_1 = require("./utils/proxyHandlers");
const wrapBrowserContext = (browserContext, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(browserContext)) {
        return browserContext;
    }
    const proxy = new Proxy(browserContext, {
        get(host, prop) {
            switch (prop) {
                case 'newPage':
                    return async (...args) => {
                        const page = await host.newPage(...args);
                        return (0, exports.wrapPage)(page, controller);
                    };
                case 'pages':
                    return async (...args) => {
                        const pages = await host.pages(...args);
                        return pages.map(p => (0, exports.wrapPage)(p, controller));
                    };
                case 'targets':
                    return () => host.targets().map(t => (0, exports.wrapTarget)(t, controller));
                case 'browser':
                    return () => (0, exports.wrapBrowser)(host.browser(), controller);
                case 'waitForTarget':
                    return async (...args) => {
                        const target = await host.waitForTarget(...args);
                        return (0, exports.wrapTarget)(target, controller);
                    };
                case 'close':
                    return async () => {
                        await controller.flush();
                        await host.close();
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapBrowserContext = wrapBrowserContext;
const wrapBrowser = (browser, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(browser)) {
        return browser;
    }
    const proxy = new Proxy(browser, {
        get(host, prop) {
            switch (prop) {
                case 'newPage':
                    return async (...args) => {
                        const page = await host.newPage(...args);
                        return (0, exports.wrapPage)(page, controller);
                    };
                case 'createIncognitoBrowserContext':
                    return async (...args) => {
                        const context = await host.createIncognitoBrowserContext(...args);
                        return (0, exports.wrapBrowserContext)(context, controller);
                    };
                case 'createBrowserContext':
                    return async (...args) => {
                        const context = await host.createBrowserContext(...args);
                        return (0, exports.wrapBrowserContext)(context, controller);
                    };
                case 'defaultBrowserContext':
                    return () => (0, exports.wrapBrowserContext)(host.defaultBrowserContext(), controller);
                case 'pages':
                    return async () => {
                        const pages = await host.pages();
                        return pages.map(p => (0, exports.wrapPage)(p, controller));
                    };
                case 'target':
                    return () => (0, exports.wrapTarget)(host.target(), controller);
                case 'targets':
                    return () => host.targets().map(t => (0, exports.wrapTarget)(t, controller));
                case 'waitForTarget':
                    return async (...args) => {
                        const target = await host.waitForTarget(...args);
                        return (0, exports.wrapTarget)(target, controller);
                    };
                case 'browserContexts':
                    return () => host.browserContexts().map(c => (0, exports.wrapBrowserContext)(c, controller));
                case 'close':
                    return async () => {
                        await controller.flush();
                        await host.close();
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapBrowser = wrapBrowser;
const wrapPage = (page, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(page)) {
        return page;
    }
    const proxy = new Proxy(page, {
        get(host, prop) {
            switch (prop) {
                case 'browserContext':
                    return () => (0, exports.wrapBrowserContext)(host.browserContext(), controller);
                case '$':
                case 'addScriptTag':
                case 'addStyleTag':
                case 'waitForSelector':
                case 'waitForXPath':
                    return async (...args) => {
                        const el = await host[prop](...args);
                        return el ? (0, exports.wrapElementHandle)(el, controller) : null;
                    };
                case '$$':
                case '$x':
                    return async (...args) => {
                        const els = await host[prop](...args);
                        return els.map(el => (0, exports.wrapElementHandle)(el, controller));
                    };
                case 'bringToFront':
                case 'click':
                case 'deleteCookie':
                case 'evaluate':
                case 'focus':
                case 'goBack':
                case 'goForward':
                case 'goto':
                case 'hover':
                case 'reload':
                case 'select':
                case 'setContent':
                case 'setCookie':
                case 'setViewport':
                case 'tap':
                case 'type':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                case 'browser':
                    return () => (0, exports.wrapBrowser)(host.browser(), controller);
                case 'target':
                    return () => (0, exports.wrapTarget)(host.target(), controller);
                case 'frames':
                    return () => host.frames().map(f => (0, exports.wrapFrame)(f, controller));
                case 'keyboard':
                    return (0, exports.wrapKeyboard)(host.keyboard, controller);
                case 'mouse':
                    return (0, exports.wrapMouse)(host.mouse, controller);
                case 'touchscreen':
                    return (0, exports.wrapTouchscreen)(host.touchscreen, controller);
                case 'mainFrame':
                    return () => (0, exports.wrapFrame)(host.mainFrame(), controller);
                case 'locator':
                    return (arg) => {
                        const locator = typeof arg === 'string'
                            ? host.locator(arg)
                            : host.locator(arg);
                        return locator ? (0, exports.wrapLocator)(locator, controller) : null;
                    };
                case 'close':
                    return async (...args) => {
                        await controller.flush();
                        return host.close(...args);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapPage = wrapPage;
const wrapTarget = (target, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(target)) {
        return target;
    }
    const proxy = new Proxy(target, {
        get(host, prop) {
            switch (prop) {
                case 'browserContext':
                    return () => (0, exports.wrapBrowserContext)(host.browserContext(), controller);
                case 'browser':
                    return () => (0, exports.wrapBrowser)(host.browser(), controller);
                case 'opener':
                    return () => {
                        const opener = host.opener();
                        return opener ? (0, exports.wrapTarget)(opener, controller) : null;
                    };
                case 'page':
                    return async () => {
                        const page = await host.page();
                        return page ? (0, exports.wrapPage)(page, controller) : null;
                    };
                case 'asPage':
                    return async () => {
                        const asPage = await host.asPage();
                        return asPage ? (0, exports.wrapPage)(asPage, controller) : null;
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapTarget = wrapTarget;
const wrapElementHandle = (elementHandle, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(elementHandle)) {
        return elementHandle;
    }
    const proxy = new Proxy(elementHandle, {
        get(host, prop) {
            switch (prop) {
                case '$':
                case 'waitForSelector':
                case 'waitForXPath':
                    return async (...args) => {
                        const el = await host.$(...args);
                        return el ? (0, exports.wrapElementHandle)(el, controller) : null;
                    };
                case '$$':
                case '$x':
                    return async (...args) => {
                        const els = await host[prop](...args);
                        return els.map(el => (0, exports.wrapElementHandle)(el, controller));
                    };
                case 'asElement':
                    return () => (0, exports.wrapElementHandle)(host.asElement(), controller);
                case 'contentFrame':
                    return async () => {
                        const frame = await host.contentFrame();
                        return frame ? (0, exports.wrapFrame)(frame, controller) : null;
                    };
                case 'frame':
                    return (0, exports.wrapFrame)(host.frame, controller);
                case 'toElement':
                    return async (...args) => (0, exports.wrapElementHandle)(await host.toElement(...args), controller);
                case 'click':
                case 'drag':
                case 'dragAndDrop':
                case 'dragEnter':
                case 'dragOver':
                case 'drop':
                case 'focus':
                case 'hover':
                case 'press':
                case 'scrollIntoView':
                case 'select':
                case 'tap':
                case 'touchEnd':
                case 'touchMove':
                case 'touchStart':
                case 'type':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapElementHandle = wrapElementHandle;
const wrapKeyboard = (keyboard, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(keyboard)) {
        return keyboard;
    }
    const proxy = new Proxy(keyboard, {
        get(host, prop) {
            switch (prop) {
                case 'down':
                case 'press':
                case 'up':
                case 'sendCharacter':
                case 'type':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapKeyboard = wrapKeyboard;
const wrapMouse = (mouse, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(mouse)) {
        return mouse;
    }
    const proxy = new Proxy(mouse, {
        get(host, prop) {
            switch (prop) {
                case 'click':
                case 'down':
                case 'drag':
                case 'dragAndDrop':
                case 'dragEnter':
                case 'dragOver':
                case 'drop':
                case 'move':
                case 'up':
                case 'wheel':
                case 'reset':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapMouse = wrapMouse;
const wrapTouchscreen = (touchscreen, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(touchscreen)) {
        return touchscreen;
    }
    const proxy = new Proxy(touchscreen, {
        get(host, prop) {
            switch (prop) {
                case 'tap':
                case 'touchEnd':
                case 'touchMove':
                case 'touchStart':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapTouchscreen = wrapTouchscreen;
const wrapDialog = (dialog, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(dialog)) {
        return dialog;
    }
    const proxy = new Proxy(dialog, {
        get(host, prop) {
            switch (prop) {
                case 'accept':
                case 'dismiss':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapDialog = wrapDialog;
const wrapFrame = (frame, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(frame)) {
        return frame;
    }
    const proxy = new Proxy(frame, {
        get(host, prop) {
            switch (prop) {
                case '$':
                case 'addScriptTag':
                case 'addStyleTag':
                case 'waitForSelector':
                case 'waitForXPath':
                    return async (...args) => {
                        const el = await host[prop](...args);
                        return el ? (0, exports.wrapElementHandle)(el, controller) : null;
                    };
                case '$$':
                case '$x':
                    return async (...args) => {
                        const els = await host[prop](...args);
                        return els.map(el => (0, exports.wrapElementHandle)(el, controller));
                    };
                case 'childFrames':
                    return () => host.childFrames().map(f => (0, exports.wrapFrame)(f, controller));
                case 'page':
                    return () => (0, exports.wrapPage)(host.page(), controller);
                case 'parentFrame':
                    return () => {
                        const f = host.parentFrame();
                        return f ? (0, exports.wrapFrame)(f, controller) : null;
                    };
                case 'locator':
                    return (arg) => {
                        const locator = typeof arg === 'string'
                            ? host.locator(arg)
                            : host.locator(arg);
                        return locator ? (0, exports.wrapLocator)(locator, controller) : null;
                    };
                case 'click':
                case 'focus':
                case 'goto':
                case 'hover':
                case 'select':
                case 'setContent':
                case 'tap':
                case 'type':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapFrame = wrapFrame;
const wrapLocator = (locator, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(locator)) {
        return locator;
    }
    const proxy = new Proxy(locator, {
        get(host, prop) {
            switch (prop) {
                case 'waitHandle':
                    return async (...args) => {
                        const handle = await host[prop](...args);
                        if (Object.prototype.hasOwnProperty.call(handle, '$$')) {
                            return (0, exports.wrapElementHandle)(handle, controller);
                        }
                        else {
                            return (0, exports.wrapJSHandle)(handle, controller);
                        }
                    };
                case 'setTimeout':
                case 'setVisibility':
                case 'setWaitForEnabled':
                case 'setEnsureElementIsInTheViewport':
                case 'setWaitForStableBoundingBox':
                case 'clone':
                case 'map':
                case 'filter':
                    return (...args) => (0, exports.wrapLocator)(host[prop](...args), controller);
                case 'click':
                case 'fill':
                case 'hover':
                case 'scroll':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(host, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapLocator = wrapLocator;
const wrapJSHandle = (frame, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(frame)) {
        return frame;
    }
    const proxy = new Proxy(frame, {
        get(host, prop) {
            switch (prop) {
                case 'asElement':
                    return () => {
                        const el = host.asElement();
                        return el ? (0, exports.wrapElementHandle)(el, controller) : null;
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(host, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(proxy);
    return proxy;
};
exports.wrapJSHandle = wrapJSHandle;
//# sourceMappingURL=puppeteerWrapping.js.map