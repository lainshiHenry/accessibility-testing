"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapTouchscreen = exports.wrapMouse = exports.wrapKeyboard = exports.wrapJSHandle = exports.wrapLocator = exports.wrapFrameLocator = exports.wrapFrame = exports.wrapElementHandle = exports.wrapPage = exports.wrapBrowser = exports.wrapBrowserContext = void 0;
const proxyHandlers_1 = require("./utils/proxyHandlers");
const wrapBrowserContext = (browserContext, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(browserContext)) {
        return browserContext;
    }
    const browserContextProxy = new Proxy(browserContext, {
        get(target, prop) {
            switch (prop) {
                case 'newPage':
                    return async (...args) => {
                        const page = await target.newPage(...args);
                        return (0, exports.wrapPage)(page, controller);
                    };
                case 'browser':
                    return () => {
                        const browser = target.browser();
                        if (!browser) {
                            return null;
                        }
                        return (0, exports.wrapBrowser)(browser, controller);
                    };
                case 'pages':
                    return (...args) => {
                        const pages = target.pages(...args);
                        return pages.map(p => (0, exports.wrapPage)(p, controller));
                    };
                case 'close':
                    return async () => {
                        await controller.flush();
                        return target.close();
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(browserContextProxy);
    return browserContextProxy;
};
exports.wrapBrowserContext = wrapBrowserContext;
const wrapBrowser = (browser, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(browser)) {
        return browser;
    }
    const browserProxy = new Proxy(browser, {
        get(target, prop) {
            switch (prop) {
                case 'newContext':
                    return async (...args) => {
                        const context = await target.newContext(...args);
                        return (0, exports.wrapBrowserContext)(context, controller);
                    };
                case 'newPage':
                    return async (...args) => {
                        const page = await target.newPage(...args);
                        return (0, exports.wrapPage)(page, controller);
                    };
                case 'contexts':
                    return (...args) => {
                        const contexts = target.contexts(...args);
                        return contexts.map(c => (0, exports.wrapBrowserContext)(c, controller));
                    };
                case 'close':
                    return async () => {
                        await controller.flush();
                        return target.close();
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(browserProxy);
    return browserProxy;
};
exports.wrapBrowser = wrapBrowser;
const wrapPage = (page, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(page)) {
        return page;
    }
    const pageProxy = new Proxy(page, {
        get(target, prop) {
            switch (prop) {
                case '$':
                    return async (...args) => {
                        const el = await target.$(...args);
                        if (!el) {
                            return null;
                        }
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case '$$':
                    return async (...args) => {
                        const els = await target.$$(...args);
                        return els.map(e => (0, exports.wrapElementHandle)(e, controller));
                    };
                case 'waitForSelector':
                    return async (...args) => {
                        const el = await target.waitForSelector(...args);
                        if (!el) {
                            return null;
                        }
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case '$$eval':
                case '$eval':
                case 'addScriptTag':
                case 'addStyleTag':
                case 'bringToFront':
                case 'check':
                case 'click':
                case 'dblclick':
                case 'dispatchEvent':
                case 'dragAndDrop':
                case 'emulateMedia':
                case 'evaluate':
                case 'fill':
                case 'focus':
                case 'goBack':
                case 'goForward':
                case 'goto':
                case 'hover':
                case 'opener':
                case 'press':
                case 'reload':
                case 'selectOption':
                case 'setChecked':
                case 'setContent':
                case 'setInputFiles':
                case 'setViewportSize':
                case 'tap':
                case 'type':
                case 'uncheck':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                case 'context':
                    return () => {
                        const context = target.context();
                        return (0, exports.wrapBrowserContext)(context, controller);
                    };
                case 'evaluateHandle':
                case 'waitForFunction':
                    return async (...args) => {
                        const handle = await target[prop](...args);
                        return (0, exports.wrapJSHandle)(handle, controller);
                    };
                case 'frame':
                case 'mainFrame':
                    return (...args) => {
                        const mainFrame = target[prop](...args);
                        if (!mainFrame) {
                            return null;
                        }
                        return (0, exports.wrapFrame)(mainFrame, controller);
                    };
                case 'frames':
                    return (...args) => {
                        const frames = target.frames(...args);
                        return frames.map(f => (0, exports.wrapFrame)(f, controller));
                    };
                case 'frameLocator':
                    return (...args) => {
                        const frameLocator = target.frameLocator(...args);
                        return (0, exports.wrapFrameLocator)(frameLocator, controller);
                    };
                case 'getByAltText':
                case 'getByLabel':
                case 'getByPlaceholder':
                case 'getByRole':
                case 'getByTestId':
                case 'getByText':
                case 'getByTitle':
                case 'locator':
                    return (...args) => {
                        const el = target[prop](...args);
                        return (0, exports.wrapLocator)(el, controller);
                    };
                case 'keyboard':
                    return (0, exports.wrapKeyboard)(target.keyboard, controller);
                case 'mouse':
                    return (0, exports.wrapMouse)(target.mouse, controller);
                case 'touchscreen':
                    return (0, exports.wrapTouchscreen)(target.touchscreen, controller);
                case 'close':
                    return async () => {
                        await controller.flush();
                        return target.close();
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(pageProxy);
    return pageProxy;
};
exports.wrapPage = wrapPage;
const wrapElementHandle = (elementHandle, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(elementHandle)) {
        return elementHandle;
    }
    const elementHandleProxy = new Proxy(elementHandle, {
        get(target, prop) {
            switch (prop) {
                case '$':
                case 'asElement':
                case 'waitForSelector':
                    return async (...args) => {
                        const el = await target[prop](...args);
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case '$$':
                    return async (...args) => {
                        const els = await target.$$(...args);
                        return els.map(e => (0, exports.wrapElementHandle)(e, controller));
                    };
                case '$$eval':
                case '$eval':
                case 'check':
                case 'click':
                case 'dblclick':
                case 'dispatchEvent':
                case 'evaluate':
                case 'evaluateHandle':
                case 'fill':
                case 'focus':
                case 'hover':
                case 'press':
                case 'scrollIntoViewIfNeeded':
                case 'selectOption':
                case 'selectText':
                case 'setChecked':
                case 'setInputFiles':
                case 'tap':
                case 'type':
                case 'uncheck':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                case 'contentFrame':
                case 'ownerFrame':
                    return async (...args) => {
                        const frame = await target[prop](...args);
                        if (!frame) {
                            return null;
                        }
                        return (0, exports.wrapFrame)(frame, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(elementHandleProxy);
    return elementHandleProxy;
};
exports.wrapElementHandle = wrapElementHandle;
const wrapFrame = (frame, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(frame)) {
        return frame;
    }
    const frameProxy = new Proxy(frame, {
        get(target, prop) {
            switch (prop) {
                case '$':
                case 'frameElement':
                case 'waitForSelector':
                    return async (...args) => {
                        const el = await target[prop](...args);
                        if (!el) {
                            return null;
                        }
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case 'evaluateHandle':
                    return async (...args) => {
                        const el = await target.evaluateHandle(...args);
                        return (0, exports.wrapJSHandle)(el, controller);
                    };
                case 'childFrames':
                    return (...args) => {
                        const frames = target.childFrames(...args);
                        return frames.map(f => (0, exports.wrapFrame)(f, controller));
                    };
                case '$$eval':
                case '$eval':
                case 'addScriptTag':
                case 'addStyleTag':
                case 'check':
                case 'click':
                case 'dblclick':
                case 'dispatchEvent':
                case 'dragAndDrop':
                case 'evaluate':
                case 'fill':
                case 'focus':
                case 'goto':
                case 'hover':
                case 'press':
                case 'selectOption':
                case 'setChecked':
                case 'setContent':
                case 'setInputFiles':
                case 'tap':
                case 'type':
                case 'uncheck':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                case 'frameLocator':
                    return (...args) => {
                        const frameLocator = target.frameLocator(...args);
                        return (0, exports.wrapFrameLocator)(frameLocator, controller);
                    };
                case 'getByAltText':
                case 'getByLabel':
                case 'getByPlaceholder':
                case 'getByRole':
                case 'getByTestId':
                case 'getByText':
                case 'getByTitle':
                case 'locator':
                    return (...args) => {
                        const el = target[prop](...args);
                        return (0, exports.wrapLocator)(el, controller);
                    };
                case 'page':
                    return () => (0, exports.wrapPage)(target.page(), controller);
                case 'parentFrame':
                    return () => {
                        const parentFrame = target.parentFrame();
                        if (!parentFrame) {
                            return null;
                        }
                        return (0, exports.wrapFrame)(parentFrame, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(frameProxy);
    return frameProxy;
};
exports.wrapFrame = wrapFrame;
const wrapFrameLocator = (frameLocator, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(frameLocator)) {
        return frameLocator;
    }
    const frameLocatorProxy = new Proxy(frameLocator, {
        get(target, prop) {
            switch (prop) {
                case 'first':
                case 'frameLocator':
                case 'last':
                case 'nth':
                    return (...args) => {
                        const frame = target[prop](...args);
                        if (!frame) {
                            return null;
                        }
                        return (0, exports.wrapFrameLocator)(frame, controller);
                    };
                case 'getByAltText':
                case 'getByLabel':
                case 'getByPlaceholder':
                case 'getByRole':
                case 'getByTestId':
                case 'getByText':
                case 'getByTitle':
                case 'locator':
                case 'owner':
                    return (...args) => {
                        const el = target[prop](...args);
                        return (0, exports.wrapLocator)(el, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(frameLocatorProxy);
    return frameLocatorProxy;
};
exports.wrapFrameLocator = wrapFrameLocator;
const wrapLocator = (locator, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(locator)) {
        return locator;
    }
    const locatorProxy = new Proxy(locator, {
        get(target, prop) {
            switch (prop) {
                case 'all':
                    return async (...args) => {
                        const els = await target.all(...args);
                        return els.map(e => (0, exports.wrapLocator)(e, controller));
                    };
                case 'blur':
                case 'check':
                case 'clear':
                case 'click':
                case 'dblclick':
                case 'dispatchEvent':
                case 'dragTo':
                case 'evaluate':
                case 'evaluateAll':
                case 'fill':
                case 'focus':
                case 'highlight':
                case 'hover':
                case 'press':
                case 'pressSequentially':
                case 'scrollIntoViewIfNeeded':
                case 'selectOption':
                case 'selectText':
                case 'setChecked':
                case 'setInputFiles':
                case 'tap':
                case 'type':
                case 'uncheck':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                case 'elementHandle':
                    return async () => {
                        const el = await target.elementHandle();
                        if (!el) {
                            return null;
                        }
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case 'elementHandles':
                    return async () => {
                        const els = await target.elementHandles();
                        return els.map(e => (0, exports.wrapElementHandle)(e, controller));
                    };
                case 'evaluateHandle':
                    return async (...args) => {
                        const handle = await target.evaluateHandle(...args);
                        return (0, exports.wrapJSHandle)(handle, controller);
                    };
                case 'and':
                case 'filter':
                case 'first':
                case 'getByAltText':
                case 'getByLabel':
                case 'getByPlaceholder':
                case 'getByRole':
                case 'getByTestId':
                case 'getByText':
                case 'getByTitle':
                case 'last':
                case 'locator':
                case 'nth':
                case 'or':
                    return (...args) => {
                        const el = target[prop](...args);
                        return (0, exports.wrapLocator)(el, controller);
                    };
                case 'contentFrame':
                case 'frameLocator':
                    return (...args) => {
                        const frame = target[prop](...args);
                        return (0, exports.wrapFrameLocator)(frame, controller);
                    };
                case 'page':
                    return () => {
                        const page = target[prop]();
                        return (0, exports.wrapPage)(page, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(locatorProxy);
    return locatorProxy;
};
exports.wrapLocator = wrapLocator;
const wrapJSHandle = (jsHandle, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(jsHandle)) {
        return jsHandle;
    }
    const jsHandleProxy = new Proxy(jsHandle, {
        get(target, prop) {
            switch (prop) {
                case 'asElement':
                    return () => {
                        const el = target.asElement();
                        if (!el) {
                            return null;
                        }
                        return (0, exports.wrapElementHandle)(el, controller);
                    };
                case 'evaluateHandle':
                    return async (...args) => {
                        const handle = await target.evaluateHandle(...args);
                        return (0, exports.wrapJSHandle)(handle, controller);
                    };
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(jsHandleProxy);
    return jsHandleProxy;
};
exports.wrapJSHandle = wrapJSHandle;
const wrapKeyboard = (keyboard, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(keyboard)) {
        return keyboard;
    }
    const keyboardProxy = new Proxy(keyboard, {
        get(target, prop) {
            switch (prop) {
                case 'down':
                case 'insertText':
                case 'press':
                case 'type':
                case 'up':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(keyboardProxy);
    return keyboardProxy;
};
exports.wrapKeyboard = wrapKeyboard;
const wrapMouse = (mouse, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(mouse)) {
        return mouse;
    }
    const mouseProxy = new Proxy(mouse, {
        get(target, prop) {
            switch (prop) {
                case 'click':
                case 'dblclick':
                case 'down':
                case 'move':
                case 'up':
                case 'wheel':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(mouseProxy);
    return mouseProxy;
};
exports.wrapMouse = wrapMouse;
const wrapTouchscreen = (touchscreen, controller) => {
    if ((0, proxyHandlers_1.isWrapped)(touchscreen)) {
        return touchscreen;
    }
    const touchscreenProxy = new Proxy(touchscreen, {
        get(target, prop) {
            switch (prop) {
                case 'tap':
                    return (0, proxyHandlers_1.proxiedGetFuncWithAnalyze)(target, prop, controller);
                default:
                    return (0, proxyHandlers_1.proxiedGetWithoutAnalyze)(target, prop);
            }
        }
    });
    (0, proxyHandlers_1.markAsWrapped)(touchscreenProxy);
    return touchscreenProxy;
};
exports.wrapTouchscreen = wrapTouchscreen;
//# sourceMappingURL=playwrightWrapping.js.map