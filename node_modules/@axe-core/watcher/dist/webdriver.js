"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebdriverController = exports.wrapWebdriver = void 0;
exports.webdriverConfig = webdriverConfig;
const Controller_1 = __importDefault(require("./Controller"));
const writeVariables_1 = __importDefault(require("./utils/writeVariables"));
const headlessNotSupportedError_1 = require("./utils/headlessNotSupportedError");
const mergeChromeArgs_1 = __importDefault(require("./utils/mergeChromeArgs"));
var webdriverWrapping_1 = require("./webdriverWrapping");
Object.defineProperty(exports, "wrapWebdriver", { enumerable: true, get: function () { return webdriverWrapping_1.wrapDriver; } });
function webdriverConfig(arg) {
    var _a;
    const chrome = require('selenium-webdriver/chrome');
    const { axe, options } = arg;
    (0, writeVariables_1.default)(axe);
    const opts = options ? options : new chrome.Options();
    const existingArgs = (((_a = opts === null || opts === void 0 ? void 0 : opts.options_) === null || _a === void 0 ? void 0 : _a.args) || []);
    opts.options_.args = (0, mergeChromeArgs_1.default)(existingArgs, {
        disableOtherExtensions: false
    });
    if (['headless', '--headless'].some(flag => { var _a, _b; return (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.options_) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b.includes(flag); })) {
        throw new headlessNotSupportedError_1.HeadlessNotSupportedError('In WebdriverJS, use "chromeOptions.addArguments(\'--headless=new\')" instead of "setHeadless(true)" or  "addArguments(\'--headless\')"');
    }
    return opts;
}
class WebdriverController extends Controller_1.default {
    constructor(driver) {
        super({ debugLoggerName: 'WebdriverController' });
        this.driver = driver;
    }
    async executeScript(fn, ...args) {
        const script = `
      const callback = arguments[arguments.length - 1];
      Promise.resolve(...arguments)
        .then(${fn})
        .then(callback);
    `;
        const result = await this.driver.executeAsyncScript(script, ...args);
        return result;
    }
}
exports.WebdriverController = WebdriverController;
//# sourceMappingURL=webdriver.js.map