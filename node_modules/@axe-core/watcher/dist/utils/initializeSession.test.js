"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const chai_1 = require("chai");
const sinon_1 = __importDefault(require("sinon"));
const proxyquire_1 = __importDefault(require("proxyquire"));
const initializeSession_1 = __importDefault(require("./initializeSession"));
describe('initializeSession', () => {
    afterEach(sinon_1.default.restore);
    const defaultParams = {
        apiKey: 'abc',
        serverURL: 'http://localhost:3000',
        watcherVersion: '1.0.0',
        sessionID: null,
        buildID: null,
        gitCommitSha: null
    };
    describe('validating input', () => {
        describe('when the API key is missing', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({});
                }, 'API key is required');
            });
        });
        describe('when the server URL is missing', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({ apiKey: 'abc' });
                }, 'Server URL is required');
            });
        });
        describe('when the watcher version is missing', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({
                        apiKey: 'abc',
                        serverURL: 'http://localhost:3000'
                    });
                }, 'Watcher version is required');
            });
        });
        describe('when the session ID is not a string', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({
                        ...defaultParams,
                        sessionID: 123
                    });
                }, 'Session ID must be a string');
            });
        });
        describe('when the build ID is not a string', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({
                        ...defaultParams,
                        buildID: 123
                    });
                }, 'Build ID must be a string');
            });
        });
        describe('when both session ID and build ID are provided', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({
                        ...defaultParams,
                        sessionID: 'abc',
                        buildID: '123'
                    });
                }, 'Session ID and Build ID are mutually exclusive. `sessionId` is deprecated, please use `buildID` instead');
            });
        });
        describe('when the git commit SHA is not a string', () => {
            it('throws an error', () => {
                chai_1.assert.throws(() => {
                    (0, initializeSession_1.default)({
                        ...defaultParams,
                        gitCommitSha: 123
                    });
                }, 'Git commit SHA must be a string');
            });
        });
    });
    describe('when the server returns a non-200 response', () => {
        afterEach(sinon_1.default.restore);
        it('throws an error', () => {
            const requestStub = sinon_1.default
                .stub()
                .returns({ statusCode: 500, getBody: () => '{"errors":["boom"]}' });
            const fn = (0, proxyquire_1.default)('./initializeSession', {
                'sync-request': requestStub
            }).default;
            chai_1.assert.throws(() => {
                fn(defaultParams);
            }, 'boom');
        });
    });
    describe('when the server returns a 200 response', () => {
        it('does not throw an error', () => {
            const expectedBody = {
                errors: [],
                warnings: [],
                session_id: 'abc'
            };
            const requestStub = sinon_1.default.stub().returns({
                statusCode: 200,
                getBody: () => JSON.stringify(expectedBody)
            });
            const fn = (0, proxyquire_1.default)('./initializeSession', {
                'sync-request': requestStub
            }).default;
            const invoke = fn(defaultParams);
            chai_1.assert.doesNotThrow(() => invoke);
            chai_1.assert.deepEqual(invoke, expectedBody.session_id);
        });
        describe('and no session_id is returned', () => {
            const expectedBody = {
                errors: [],
                warnings: []
            };
            const sessionID = 'xyz';
            describe('and a sessionID is provided', () => {
                it('uses the sessionID', () => {
                    const requestStub = sinon_1.default.stub().returns({
                        statusCode: 200,
                        getBody: () => JSON.stringify(expectedBody)
                    });
                    const fn = (0, proxyquire_1.default)('./initializeSession', {
                        'sync-request': requestStub
                    }).default;
                    const invoke = fn({
                        ...defaultParams,
                        ...{ sessionID }
                    });
                    chai_1.assert.deepEqual(invoke, sessionID);
                });
            });
            describe('and a buildID is provided', () => {
                it('throws', () => {
                    const requestStub = sinon_1.default.stub().returns({
                        statusCode: 200,
                        getBody: () => JSON.stringify(expectedBody)
                    });
                    const fn = (0, proxyquire_1.default)('./initializeSession', {
                        'sync-request': requestStub
                    }).default;
                    const buildID = 'def';
                    chai_1.assert.throws(() => fn({
                        ...defaultParams,
                        ...{ buildID }
                    }), 'Failed to initialize session based on build_id. Try again later.');
                });
            });
            describe('and neither a sessionID nor a buildID are provided', () => {
                it('uses a generated UUID', () => {
                    const requestStub = sinon_1.default.stub().returns({
                        statusCode: 200,
                        getBody: () => JSON.stringify(expectedBody)
                    });
                    const generatedID = 'ghi';
                    const uuidStub = sinon_1.default.stub().returns(generatedID);
                    const fn = (0, proxyquire_1.default)('./initializeSession', {
                        'sync-request': requestStub,
                        uuid: { v4: uuidStub }
                    }).default;
                    const invoke = fn(defaultParams);
                    chai_1.assert.deepEqual(invoke, generatedID);
                });
            });
        });
    });
});
//# sourceMappingURL=initializeSession.test.js.map