"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const updateAutoAnalyze_1 = __importDefault(require("./utils/updateAutoAnalyze"));
const sendResultsToServer_1 = __importDefault(require("./sendResultsToServer"));
const createDebugger_1 = __importDefault(require("./createDebugger"));
class Controller {
    constructor({ debugLoggerName }) {
        this.isStopped = false;
        this.debugLogger = (0, createDebugger_1.default)(debugLoggerName);
    }
    async start() {
        (0, updateAutoAnalyze_1.default)(true);
        this.isStopped = false;
        await this.executeScript(() => {
            if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                return Promise.resolve();
            }
            return new Promise(resolve => {
                const fn = () => {
                    window.removeEventListener('axe:start-auto-mode-done', fn);
                    resolve();
                };
                window.addEventListener('axe:start-auto-mode-done', fn);
                const event = new CustomEvent('axe:start-auto-mode');
                window.dispatchEvent(event);
            });
        });
    }
    async stop() {
        (0, updateAutoAnalyze_1.default)(false);
        this.isStopped = true;
        await this.executeScript(() => {
            if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                return Promise.resolve();
            }
            return new Promise(resolve => {
                const fn = () => {
                    window.removeEventListener('axe:stop-auto-mode-done', fn);
                    resolve();
                };
                window.addEventListener('axe:stop-auto-mode-done', fn);
                const event = new CustomEvent('axe:stop-auto-mode');
                window.dispatchEvent(event);
            });
        });
    }
    async analyze({ __Method, __UserRequestedAnalyze = true } = {}) {
        this.debugLogger(`Analyze: Invoked${__Method ? ` - ${__Method}` : ''}`);
        if (this.isStopped && !__UserRequestedAnalyze) {
            this.debugLogger('Analyze: Skipped', {
                isStopped: this.isStopped,
                __UserRequestedAnalyze
            });
            return;
        }
        const result = await this.executeScript((userRequestedAnalyze) => {
            if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                return Promise.resolve({ message: 'Skipped - Invalid protocol' });
            }
            return new Promise(resolve => {
                const fn = (event) => {
                    window.removeEventListener('axe:manual-mode-analyze-done', fn);
                    resolve(event.detail);
                };
                window.addEventListener('axe:manual-mode-analyze-done', fn);
                const event = new CustomEvent('axe:manual-mode-analyze', {
                    detail: { userRequestedAnalyze }
                });
                window.dispatchEvent(event);
            });
        }, __UserRequestedAnalyze);
        this.debugLogger(`Analyze: ${result.message}`);
    }
    async flush() {
        this.debugLogger('Flush: Invoked (may analyze implicitly)');
        const results = await this.executeScript(() => {
            if (!['http:', 'https:', 'file:'].includes(window.location.protocol)) {
                return Promise.resolve([]);
            }
            return new Promise(resolve => {
                const receivedResults = [];
                const onFlushEnd = () => {
                    window.removeEventListener('axe:flush-end', onFlushEnd);
                    window.removeEventListener('axe:result', onAxeResult);
                    resolve(receivedResults);
                };
                const onAxeResult = (e) => {
                    receivedResults.push(...e.detail);
                };
                window.addEventListener('axe:result', onAxeResult);
                window.addEventListener('axe:flush-end', onFlushEnd);
                const event = new CustomEvent('axe:flush-start');
                window.dispatchEvent(event);
            });
        });
        this.debugLogger(`Flush: Received ${results.length} results`);
        await (0, sendResultsToServer_1.default)({
            results,
            debugLogger: this.debugLogger
        });
        this.debugLogger('Flush: Complete');
    }
}
exports.default = Controller;
//# sourceMappingURL=Controller.js.map